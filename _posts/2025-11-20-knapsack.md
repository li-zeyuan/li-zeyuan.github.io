---
title: 背包问题
date: 2025-11-20 00:00:00 +0800
categories: [root, algorithm, dynamic-programming]
tags: [algorithm, dynamic programming]
author: ahern
---

![img.png](../assets/images/img_45.png)

## 0-1背包问题

### 题目描述

一共有N件物品，第i（i从1开始）件物品的体积为w[i]，价值为v[i]。在总体积不超过背包上限C的情况下，能够装入背包的最大价值是多少?

如：
```
物品1: weight=7, value=42  
物品2: weight=3, value=12  
物品3: weight=4, value=40  
物品4: weight=5, value=25  

背包容量C=10; 则最大价值为:  40 + 25 = 65
```


### 解题思路

$S(i, c)$ 表示对与第 i 件物品，容量为 c 的背包，能获取的最大价值。则对于第 i 件物品，有放入和不放入两种选择：

1、选择不放入: 第 i 件物品重量超过背包容量，$w_i > c$。则只能选择不放入，$S(i, c) = S(i-1, c)$。

2、选择放入: 第 i 件物品重量不超过背包容量，$w_i \le c$。则可以选择放入，$S(i, c) = S(i-1, c - w_i) + v_i$。
$v_i$可能是负数，所以需要和不放入情况对比，取最大值。则$S(i, c) = max(S(i-1, c), s(i, c - w_i) + v_i)$

3、临界条件： 当没有物品或者背包容量为0时，最大价值为0，即$S(0, c) = 0$或$S(i, 0) = 0$。

<br/>
综上所述，状态转移方程如下：

$$
S(i, c) =
\begin{cases}
S(i-1, c), & \text{if } w_i > c \\[6pt]
S(i-1, c - w_i) + v_i, & \text{if } w_i \le c \\[6pt]
0, & \text{if } i = 0 \text{ or } c = 0
\end{cases}
$$

### 自底向上
从解决子问题出发，逐步解决大问题。
<br/>

用一张 I * C 表格记录每个子问题的解，I表示物品数量，C表示背包容量。$S(0, c)$和$S(i, 0)$都等于0

![img.png](../assets/images/img_46.png)

<br/>

从$S(1, 1)$开始，显然$1 <= w_1$，所以$S(1, 1) = S(0, 1) = 0$。依次类推，直到$S(1, 7)$，此时$7 <= w_1$，所以$S(1, 7) = max(S(0, 7), S(0, 0) + 42) = 42$。

![img.png](../assets/images/img_47.png)

<br/>

依次类推，直到填满整张表格，最终得到$S(4, 10) = 65$。

![img.png](../assets/images/img_48.png)

<br/>

$$
S(4, 10) = max(S(3, 10), S(3, 5) + 25)
$$

通过以上分析，可以得出自底向上的代码实现如下：
```go

```
由于需要用到I * C的表格存储中间结果，空间复杂度和空间复杂度为O(IC)。

### 自顶向下
要解决大问题，先拆解成小问题，递归求解小问题，最终得到大问题的解。

## 完全背包问题

## 参考
- https://infinityglow.github.io/study/algorithm/dynamic-programming/knapsack-problem/

